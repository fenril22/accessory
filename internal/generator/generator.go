package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/spf13/afero"
	"golang.org/x/tools/go/packages"

	"github.com/masaushi/accessory/internal/objects"
)

type generator struct {
	buf *bytes.Buffer
}

type parameters struct {
	Receiver     string
	Struct       string
	Field        string
	GetterMethod string
	SetterMethod string
	Type         string
	ZeroValue    string // used only when generating getter
	Lock         *string
}

// Generate generates a file and accessor methods in it.
func Generate(fs afero.Fs, pkg *objects.Package, typeName, output, receiverName string, lockName *string) error {
	g := generator{buf: new(bytes.Buffer)}

	importMap := make(map[string]*packages.Package, len(pkg.Imports))
	for _, imp := range pkg.Imports {
		// temporary assign nil
		importMap[imp.Name] = imp
	}

	accessors := make([]string, 0)
	imports := make([]*packages.Package, 0, len(importMap))

	for _, st := range pkg.Structs {
		if st.Name != typeName {
			continue
		}

		for _, field := range st.Fields {
			if field.Tag == nil {
				continue
			}

			params := g.setupParameters(pkg, st, field, receiverName, lockName)

			if field.Tag.Getter != nil {
				getter, err := g.getterGenerate(params)
				if err != nil {
					return err
				}
				accessors = append(accessors, getter)
			}
			if field.Tag.Setter != nil {
				setter, err := g.setterGenerate(params)
				if err != nil {
					return err
				}
				accessors = append(accessors, setter)
			}

			if splitted := strings.Split(strings.TrimPrefix(params.Type, "*"), "."); len(splitted) > 1 {
				otherPackage := splitted[0]
				imports = append(imports, importMap[otherPackage])
			}
		}
	}

	g.write(pkg.Name, imports, accessors)

	content, err := g.format()
	if err != nil {
		return err
	}

	outputFile := g.outputFile(output, typeName, pkg.Dir)
	return afero.WriteFile(fs, outputFile, content, 0644)
}

func (g *generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(g.buf, format, args...)
}

func (g *generator) write(pkgName string, imports []*packages.Package, accessors []string) {
	g.printf("// Code generated by accessory; DO NOT EDIT.\n")
	g.printf("\n")
	g.printf("package %s\n", pkgName)
	g.printf("\n")

	if len(imports) > 0 {
		// Ensure imports are same order as previous if there are no declaration changes.
		sort.Slice(imports, func(i, j int) bool {
			return imports[i].Name < imports[j].Name
		})

		g.printf("import (\n")
		for _, imp := range imports {
			if imp.Name == filepath.Base(imp.PkgPath) {
				g.printf("\t\"%s\"\n", imp.PkgPath)
			} else {
				g.printf("\t%s \"%s\"\n", imp.Name, imp.PkgPath)
			}
		}
		g.printf(")\n")
	}

	for i := range accessors {
		g.printf("%s\n", accessors[i])
	}
}

func (g *generator) setterGenerate(
	params *parameters,
) (string, error) {
	var lockingCode string
	if params.Lock != nil {
		lockingCode = ` {{.Receiver}}.{{.Lock}}.Lock()
		defer {{.Receiver}}.{{.Lock}}.Unlock()
		`
	}

	var tpl = `
	func ({{.Receiver}} *{{.Struct}}) {{.SetterMethod}}(val {{.Type}}) {
	` +
		lockingCode + // inject locing code
		`{{.Receiver}}.{{.Field}} = val
	}`

	t := template.Must(template.New("setter").Parse(tpl))
	buf := new(bytes.Buffer)

	if err := t.Execute(buf, params); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func (g *generator) getterGenerate(
	params *parameters,
) (string, error) {
	var lockingCode string
	if params.Lock != nil {
		lockingCode = `{{.Receiver}}.{{.Lock}}.Lock()
		defer {{.Receiver}}.{{.Lock}}.Unlock()
		`
	}

	var tpl = `
	func ({{.Receiver}} *{{.Struct}}) {{.GetterMethod}}() {{.Type}} {
		if {{.Receiver}} == nil {
			return {{.ZeroValue}}
		}
		` +
		lockingCode + // inject locing code
		`return {{.Receiver}}.{{.Field}}
	}`

	t := template.Must(template.New("getter").Parse(tpl))
	buf := new(bytes.Buffer)

	if err := t.Execute(buf, params); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func (g *generator) setupParameters(
	pkg *objects.Package,
	st *objects.Struct,
	field *objects.Field,
	receiverName string,
	lockName *string,
) *parameters {
	typeName := g.typeName(pkg.Types, field.Type)
	getter, setter := g.methodNames(field)
	return &parameters{
		Receiver:     g.receiverName(receiverName, st.Name),
		Struct:       st.Name,
		Field:        field.Name,
		GetterMethod: getter,
		SetterMethod: setter,
		Type:         typeName,
		ZeroValue:    g.zeroValue(field.Type, typeName),
		Lock:         lockName,
	}
}

func (g *generator) receiverName(userInput string, structName string) string {
	if userInput != "" {
		// Do nothing if receiver name specified in args.
		return userInput
	}

	// Use the first letter of struct as receiver if receiver name is not specified.
	return strings.ToLower(string(structName[0]))
}

func (g *generator) methodNames(field *objects.Field) (getter, setter string) {
	if getterName := field.Tag.Getter; getterName != nil && *getterName != "" {
		getter = *getterName
	} else {
		getter = strings.Title(field.Name)
	}

	if setterName := field.Tag.Setter; setterName != nil && *setterName != "" {
		setter = *setterName
	} else {
		setter = "Set" + strings.Title(field.Name)
	}

	return getter, setter
}

func (g *generator) typeName(pkg *types.Package, t types.Type) string {
	return types.TypeString(t, func(p *types.Package) string {
		// type is defined in same package
		if pkg == p {
			return ""
		}
		// path string(like example.com/user/project/package) into slice
		return p.Name()
	})
}

func (g *generator) zeroValue(t types.Type, typeString string) string {
	switch t := t.(type) {
	case *types.Pointer:
		return "nil"
	case *types.Array:
		return "nil"
	case *types.Slice:
		return "nil"
	case *types.Chan:
		return "nil"
	case *types.Interface:
		return "nil"
	case *types.Map:
		return "nil"
	case *types.Signature:
		return "nil"
	case *types.Struct:
		return typeString + "{}"
	case *types.Basic:
		info := types.Typ[t.Kind()].Info()
		switch {
		case types.IsNumeric&info != 0:
			return "0"
		case types.IsBoolean&info != 0:
			return "false"
		case types.IsString&info != 0:
			return `""`
		}
	case *types.Named:
		if types.Identical(t, types.Universe.Lookup("error").Type()) {
			return "nil"
		}

		return g.zeroValue(t.Underlying(), typeString)
	}

	return "nil"
}

func (g *generator) outputFile(output, typeName, dir string) string {
	if output == "" {
		// Use snake_case name of type as output file if output file is not specified.
		// type TestStruct will be test_struct_accessor.go
		var firstCapMatcher = regexp.MustCompile("(.)([A-Z][a-z]+)")
		var articleCapMatcher = regexp.MustCompile("([a-z0-9])([A-Z])")

		name := firstCapMatcher.ReplaceAllString(typeName, "${1}_${2}")
		name = articleCapMatcher.ReplaceAllString(name, "${1}_${2}")
		output = strings.ToLower(fmt.Sprintf("%s_accessor.go", name))
	}

	return filepath.Join(dir, output)
}

func (g *generator) format() ([]byte, error) {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		return g.buf.Bytes(), err
	}
	return src, nil
}
